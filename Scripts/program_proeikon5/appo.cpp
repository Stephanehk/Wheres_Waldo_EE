#include <cstdio>
#include <cstdlib>
#include <cctype>
#include <imgall>

//typedef VET2<int> PONTOI2;
typedef VETOR<PONTOI2> EE;

//#define range

const int FIM=0xffffffff;
IMGGRY ent,sai; EE ee;

//<<<<<<<<<<<<<<<< filt <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
typedef struct { int e,l,r; } NOFILT;
// e=indice do ee.
//   Valor 0xffffffff (FIM) indica folha da arvore.
// l=indice da subarvore a esquerda.
//   Quando for folha, valor da media.
// r=indice da subarvore a direita.
class FILT {
 public:
  NOFILT *v; int nf,tf;
  NOFILT &operator [] (int i)
    {
      #ifdef range
      if (!(0<=i && i<nf)) erro("FILT indice fora");
      #endif
      return v[i];
    }
  void operator = (NOFILT *p) { v=p; }
  void aloc(int n) { nf=n; tf=0; v=(NOFILT *)aloca(sizeof(NOFILT)*nf); }
  FILT(void) { v=0; nf=tf=0; }
  int insere(int ep, int lp, int rp);
  void impfilt(char *st);
  void lefilt(char *st);
};
FILT filt;

int FILT::insere(int ep, int lp, int rp)
// Usado para inserir no interno e folha
{ if (tf>=nf) { nf=nf+nf/2; v=(NOFILT *)realoca(v,sizeof(NOFILT)*nf); }
  v[tf].e=ep; v[tf].l=lp; v[tf].r=rp;
  tf++; return tf-1;
}

/*
void FILT::impfilt(char *st)
{ FILE *arq; int e;

  arq=fopen(st,"wb");
  if (arq==NULL) erro("Erro na abertura de arquivo");
  e=setvbuf(arq,NULL,_IOFBF,0x10000);
  if (e!=0) erro("Faltou memoria setvbuf");

  e=ee.n(); fwrite(&e,1,sizeof(e),arq);
  fwrite(ee.vet,ee.n(),sizeof(PONTOI2),arq);
  fwrite(&(filt.tf),1,sizeof(filt.tf),arq);
  fwrite(filt.v,filt.tf,sizeof(NOFILT),arq);
  fclose(arq);
}
*/

void FILT::lefilt(char *st)
{ FILE *arq; int e;

  arq=fopen(st,"rb");
  if (arq==NULL) erro("The specified filter does not exist.");
  e=setvbuf(arq,NULL,_IOFBF,0x10000);
  if (e!=0) erro("Faltou memoria setvbuf");

  fread(&e,1,sizeof(e),arq); ee.resize(e);
  fread(ee.vet,ee.n(),sizeof(PONTOI2),arq);

  fread(&e,1,sizeof(e),arq); filt.aloc(e); filt.tf=e;
  fread(filt.v,e,sizeof(NOFILT),arq);

  fclose(arq);
}

/*
void impfilt(void)
{ int i;
  printf("****************** impfilt *********************\n");
  for (i=0; i<100; i++) {
    printf("i=%04d e=%04d l=%04d r=%04d\n",
           i,filt.v[i].e,filt.v[i].l,filt.v[i].r);
  }
  printf("\n");
}
*/

BYTE entwee(PONTOI2 w, int ie)
{ return ent(w(0)+ee(ie)(0),w(1)+ee(ie)(1)); }

BYTE saiw(PONTOI2 w)
{ return sai(w(0),w(1)); }

//<<<<<<<<<<<< Acha/restaura <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
BYTE acha(int l, int c)
{ int i,ie; PONTOI2 w; BYTE b;

  w(0)=l; w(1)=c; i=filt.tf-1;
  while (filt[i].e!=FIM) {
    ie=filt[i].e;
    b=entwee(w,ie);
    if (b==0) i=filt[i].l;
    else i=filt[i].r;
  }
  return BYTE(filt[i].l);
}

void restaura(void)
{ int l,c,v;
  int total,contador,umpct;

  contador=0; total=ent.nl()*ent.nc(); umpct=total/100;

  for (l=0; l<ent.nl(); l++)
    for (c=0; c<ent.nc(); c++) {

      if (contador%umpct==0) {
        fprintf(stderr,"%10.3f%% concluded...\r",100.0*contador/total);
      }
      contador++;

      v=acha(l,c);
      sai(l,c)=v;
    }
  fprintf(stderr,"%10.3f%% concluded...\r",100.0);
}

void binariza(IMGGRY& a)
{ for (int l=0; l<a.nl(); l++)
    for (int c=0; c<a.nc(); c++) {
      if (a(l,c)<=127) a(l,c)=0;
      else a(l,c)=255;
    }
}

//<<<<<<<<<<<< main <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
int main(int argc, char **argv)
{ int t1,t2,t3,t4;

  if (argc!=4) {
    printf("AppO: Applies Occam's razor decision-tree for inverse halftoning.\n");
    printf("AppO QX.BMP Filter.CTO QP.TGA\n");
    printf("  QX.BMP = image to-be-inverse-halftoned (uncompressed BMP)\n");
    printf("  Filter.CTO = Occam's decision-tree generated by BldO (CTO)\n");
    printf("  QP.TGA = inverse-halftoned image (uncompressed TGA)\n");
    erro("Error: Invalid quantity of arguments.");
  }
  t1=centseg();

  le(ent,argv[1]); ent.backg()=255; binariza(ent);
  sai.resize(ent.nl(),ent.nc()); sai.backg()=128;
  filt.lefilt(argv[2]);
  t2=centseg();

  restaura();
  t3=centseg();

  sai.ImpTga(argv[3]);
  t4=centseg();

  printf("\nInverse halftoning is finished\n");
  //printf("-------------------\n");
  //printf("Tamanho da imagem: linhas=%d colunas=%d pixels=%d\n",
  //       ent.nl(),ent.nc(),ent.nl()*ent.nc());
  //printf("-------------------\n");
  printf("Total processing time: %6.2f\n",(t4-t1)/100.0);
  //printf("Tempo de processamento: %6.2f\n",(t3-t2)/100.0);
  //printf("Tempo de leitura/escrita: %6.2f\n",((t2-t1)+(t4-t3))/100.0);
  printf("\n");
}
